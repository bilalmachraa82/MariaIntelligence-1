/**
 * Fixed Gemini API Connectivity Tests
 * Updated expectations to match actual service behavior
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { GeminiService } from '@server/services/gemini.service';
import { configureGeminiMock, mockGeminiService } from './mcp/mocks/gemini-service.mock';

describe('Gemini API Connectivity', () => {
  let geminiService: any;

  beforeEach(() => {
    vi.clearAllMocks();
    process.env.GOOGLE_GEMINI_API_KEY = 'test-api-key';
    geminiService = new GeminiService();
  });

  describe('Connection Establishment', () => {
    it('should successfully validate API key with proper response', async () => {
      configureGeminiMock.success();
      
      const result = await geminiService.testConnection();
      
      expect(result.success).toBe(true);
      expect(result.message).toContain('sucesso');
      expect(result.latency).toBeGreaterThan(0);
    });

    it('should handle API key validation failure', async () => {
      configureGeminiMock.authFailure();
      
      const result = await geminiService.testConnection();
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('invÃ¡lida');
    });

    it('should handle network timeouts properly', async () => {
      configureGeminiMock.timeout();
      
      await expect(geminiService.testConnection()).rejects.toThrow('timeout');
    });
  });

  describe('Error Handling', () => {
    it('should handle 429 rate limit errors', async () => {
      configureGeminiMock.rateLimited();
      
      const result = await geminiService.testConnection();
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('429');
    });

    it('should handle 500 internal server errors', async () => {
      configureGeminiMock.serverError();
      
      const result = await geminiService.testConnection();
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('500');
    });
  });
});
