MissÃ£o: corrigir prioridades de serviÃ§o, unificar a rota OCR, remover dependÃªncias desnecessÃ¡rias do Gemini no parser, criar componentes de UI em falta e ajustar testes.
Resultado esperado: upload de PDF âœ highlights âœ validaÃ§Ã£o âœ reserva gravada, sem erros 500 e sem quota Gemini.
Markdown
# ğŸš€ Sprint "Mistral OCR FINAL"

## 1. VariÃ¡veis de Ambiente
- [ ] Em `.env`, garantir:  PRIMARY_AI=openrouter
OR_MODEL=mistral-ocr
Yaml
- [ ] Remover/renomear `GOOGLE_GEMINI_API_KEY` se nÃ£o for usar Gemini no OCR.

---

## 2. Backâ€‘end

### 2.1 AI Adapter
- [ ] **/server/services/ai-adapter.service.ts**  
```ts
private static defaultName = process.env.PRIMARY_AI ?? "openrouter";
static get(name = AiAdapter.defaultName) { â€¦ }
Remove fallback implÃ­cito para Gemini.
2.2 Rota OCR
 /server/routes.ts

Converge para /api/ocr (DELETE /api/ocr/process para evitar confusÃ£o).

 ocr.controller.ts

Exporta postOcr para /api/ocr.

Recebe multipart/form-data, decide provider e devolve {reservations[], boxes, missing[]}.

2.3 Parser
 /server/parsers/parseReservations.ts

Eliminar qualquer chamada a GeminiService.

Fluxo: se JSON faltam campos â†’ regex heurÃ­stica â†’ retorna missing[].

2.4 Propriedades
 Prisma schema:
 model Property {
  id        Int      @id @default(autoincrement())
  name      String
  aliases   String[] @default([])
  // â€¦
}
npx prisma migrate dev -n add_aliases_to_property

 property.service.ts
static matchByAlias(rawName: string): { id: number; score: number } | null
Usa StringSimilarity.compareTwoStrings().
3. Frontâ€‘end
3.1 UploadPDF
 /client/src/pages/pdf-upload/index.tsx

Usa fetch("/api/ocr?provider=auto") e aguarda JSON.

3.2 ValidationDrawer
 /client/src/components/validation-drawer.tsx (novo)

import { pdfjs } from "pdfjs-dist/legacy/build/pdf"

Desenha <rect> com boxes (page coords).

Renderiza form dinÃ¢mico para missing[].

3.3 Hook use-pdf-upload
 Ajustar handleFileUpload para usar rota nova e setar extractedData, missing.

3.4 ReservationsService
 saveReservation() faz POST /api/reservations com status: missing.length ? "pending":"confirmed".

4. Testes
 Adaptar jest.config.js a ESM.

 Criar tests/ocr.spec.ts:
 
it("processa PDF de Sete Rios", async () => {
   const res = await request(app)
      .post("/api/ocr")
      .attach("pdf", "__tests__/data/Controlo_Sete Rios.pdf");
   expect(res.status).toBe(200);
   expect(res.body.reservations[0].propertyId).toBeDefined();
});
 Atualizar scripts test-ai-adapter* â†’ remover Gemini paths.

Scripts utilitÃ¡rios
 scripts/ocr-benchmark.ts (usando axios & cli-table3).

6. Lint & Build
 pnpm dlx eslint . --fix

 tsc --noEmit sem erros.

7. QA Manual
 Upload 3 PDFs (Aroeira I, SeteÂ Rios, manuscrito de teste) â†’ verificar highlights.

 Reserva com nome diferente â†’ UI pede <Select property> e grava.

 Logs exibem provider:"openrouter" latency_ms < 5000.

8. DocumentaÃ§Ã£o
 Atualizar README.md > seÃ§Ã£o OCR Workflow.

 Incluir tabela de env vars obrigatÃ³rias.

ğŸŸ¢ CritÃ©rio de aceite final
pnpm dev âœ GUI permite importar PDF, validar e gravar.

npm test âœ 0 falhas.

node scripts/ocr-benchmark.js âœ CER mÃ©dio â‰¤â€¯10â€¯%, p95 latÃªncia â‰¤â€¯6â€¯s.

Gemini quota error nÃ£o aparece mais nos logs.

Boa implementaÃ§Ã£o! Qualquer 500 ou 422 que apareÃ§a, imprime stack trace e chama ChatGPT para debug rÃ¡pido.

yaml

---

### ğŸ›‘â€¯PossÃ­veis armadilhas finais (nÃ£o esquecer!)

1. **Limite 20â€¯MB** no OpenRouter â€“ se algum PDF exceder, dividir em pÃ¡ginas.  
2. **CORS** â€“ se o front em `vite` e API no mesmo domÃ­nio â€‘ ok; caso contrÃ¡rio, configurar `cors()` middleware.  
3. **PDF.js & Vite** â€“ precisa de `define: { 'process.env': {} }` no `vite.config.ts` para evitar erro de build.  
4. **Prisma migrate** no Replit demora â†’ usar `npx prisma migrate deploy` no boot.  

Cumprindo o prompt acima, o sistema deve entrar em â€œverdeâ€ e o Gemini deixa de interferir no OCR. Se algo estourar, manda o log!

