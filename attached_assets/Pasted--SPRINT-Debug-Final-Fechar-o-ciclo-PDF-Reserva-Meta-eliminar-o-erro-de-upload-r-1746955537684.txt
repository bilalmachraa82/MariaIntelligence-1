# ğŸÂ SPRINT "DebugÂ Final" â€“Â Fechar o ciclo PDFÂ â†’Â Reserva

> **Meta:** eliminar o erro de upload, remover dependÃªncias do Gemini no OCR e alinhar frontâ€‘endÂ / backâ€‘end para ficar 100â€¯% funcional.

---

## 0Â | VariÃ¡veis de Ambiente (jÃ¡ OK)

```dotenv
PRIMARY_AI=openrouter
OR_MODEL=mistral-ocr
OPENROUTER_API_KEY=<tuaâ€‘key>
HF_TOKEN=<hfâ€‘token>
```

---

## 1Â |Â Backâ€‘end

### 1.1Â Remover rota antiga

`server/routes.ts`

```ts
// ğŸ”¥Â APAGA ou comenta
// router.post("/api/upload-pdf", ...);

// âœ…Â MantÃ©m apenas a rota nova
router.post("/api/ocr", upload.single("pdf"), ocrController.postOcr);
```

### 1.2Â Compatibilidade opcional

`ocr.controller.ts` â€“Â logo antes de devolver:

```ts
return res.json({
  success: true,
  provider,
  reservations,
  boxes,
  missing,
  extractedData: reservations   //  <â€‘â€‘Â para nÃ£o partir o front antigo (atÃ© trocares)
});
```

### 1.3Â Parser sem Gemini

`server/parsers/parseReservations.ts`

```ts
// 1) REMOVE ou comenta a linha:
// const gpt = await parseReservationDataWithGemini(...);
// 2) MantÃ©m apenas regex + RolmOCR quando handwritingScore > 0.4
```

---

## 2Â |Â Base de dados â€“ aliases

`prisma/schema.prisma`

```prisma
model Property {
  id       Int      @id @default(autoincrement())
  name     String
  aliases  String[] @default([])
  // ...
}
```

```bash
npx prisma migrate dev -n add_aliases
```

`server/services/property.service.ts` â€“ implementar funÃ§Ã£o `matchByAlias` (ver versÃ£o anterior).

---

## 3Â |Â Frontâ€‘end

### 3.1Â Hook de upload

`client/src/lib/ocr.ts`

```ts
export async function processFiles(files: File[]) {
  const fd = new FormData();
  files.forEach(f => fd.append("pdf", f));
  const r = await fetch("/api/ocr?provider=auto", { method: "POST", body: fd });
  if (!r.ok) throw new Error("Falha no OCR");
  return r.json();   // â†’ { reservations, boxes, missing }
}
```

### 3.2Â Substituir chamada antiga

`client/src/hooks/use-pdf-upload.ts` â€“ usar a funÃ§Ã£o acima; remover referÃªncia a `/api/upload-pdf`.

### 3.3Â ValidationDrawer (mÃ­nimo viÃ¡vel)

`client/src/components/ValidationDrawer.tsx`

```tsx
/* PDF render + rects omitido por brevidade */
<Form>
  {missing.includes("propertyId") && <Select options={properties} ... />}
  {/* outros campos em falta */}
  <Button onClick={() => saveReservation(finalData)}>Guardar</Button>
</Form>
```

---

## 4Â |Â Endpoint de OrÃ§amento

**Problema:** a versÃ£o actual calcula apenas `total = nightsÂ Ã— nightlyRate` com 10â€¯% de margem; nÃ£o considera limpeza, comissÃ£o das plataformas nem impostos.

### 4.1Â Requisitos reais

| Campo                         | Fonte                             | ObrigatÃ³rio                  |
| ----------------------------- | --------------------------------- | ---------------------------- |
| `propertyId`                  | dropdown ou OCR                   | âœ“                            |
| `checkInDate`, `checkOutDate` | reservas existentes ou form       | âœ“                            |
| `nightlyRate`                 | tabela de tarifas por propriedade | se nÃ£o existir, input manual |
| `cleaningFee`                 | tabela propriedade                | opcional                     |
| `platformFeePct`              | BookingÂ =Â 15â€¯%, AirbnbÂ =Â 3â€¯%â€¦     | opcional                     |
| `vatPct`                      | config globalÂ (IVA)               | opcional                     |

### 4.2Â Controlador actualizado

`server/controllers/budget.controller.ts`

```ts
export async function estimate(req, res) {
  try {
    const { propertyId, checkInDate, checkOutDate, nightlyRate, cleaningFee = 0 } = req.body;
    const nights = (new Date(checkOutDate) - new Date(checkInDate)) / 864e5;
    if (!propertyId || !checkInDate || !checkOutDate) return res.status(400).json({error:"Missing fields"});

    // Buscar dados da BD
    const prop = await prisma.property.findUnique({ where:{ id: propertyId } });
    const rate = nightlyRate ?? prop.defaultRate;

    const subtotal = nights * rate;
    const platformFee = subtotal * (prop.platformFeePct ?? 0.15);
    const vat = (subtotal + cleaningFee) * (prop.vatPct ?? 0.23);
    const total = subtotal + cleaningFee + platformFee + vat;

    res.json({ nights, subtotal, cleaningFee, platformFee, vat, total });
  } catch(e) {
    res.status(500).json({error:e.message});
  }
}
```

### 4.3Â Rota

```ts
router.post("/api/budgets/estimate", validateBody(schema), budgetController.estimate);
```

*(`validateBody` com `zod` ou `joi` para garantir campos obrigatÃ³rios)*

### 4.4Â Testes Jest

`tests/budget.spec.ts`

```ts
it("calcula orÃ§amento completo", async () => {
  const res = await request(app).post("/api/budgets/estimate").send({
    propertyId: 1,
    checkInDate: "2025-07-01",
    checkOutDate: "2025-07-06",
    nightlyRate: 120,
    cleaningFee: 30
  });
  expect(res.status).toBe(200);
  expect(res.body.total).toBeGreaterThan(0);
  expect(res.body.nights).toBe(5);
});
```

---

## 5Â |Â Dashboard â€“ fix datas

`server/services/dashboard.service.ts`

```ts
const toDate = (d:any)=> new Date(d);
const nights = stays.reduce((sum,s)=> sum + (toDate(s.checkOutDate)-toDate(s.checkInDate))/864e5, 0);
```

---

## 6Â |Â Testes mÃ­nimos (Jest)

`tests/ocr.spec.ts`

```ts
it("OCR via OpenRouter", async ()=> {
 const res = await request(app).post("/api/ocr").attach("pdf", "tests/Controlo_Aroeira I.pdf");
 expect(res.status).toBe(200);
 expect(res.body.provider).toBe("openrouter");
});
```

---

## 7Â |Â QA Manual

1. Carregar `Controlo_Aroeira I.pdf` â†’ deve aparecer drawer com campos; se faltar propriedade, dropdown visÃ­vel.
2. Guardar â†’ reserva surge em `/dashboard`.
3. Criar orÃ§amento rÃ¡pido â†’ `/api/budgets/estimate` devolve 200.
4. Dashboard mensal mostra nÃºmero >Â 0 de noites.

---

## 8Â |Â Diretrizes adicionais de qualidade e workflow

*(inspiradas no guia fornecido)*

* **Nada de "fallbacks" silenciosos**: se o OCR falhar, devolve erro 422; nÃ£o mudes para Gemini.
* **Levanta exceÃ§ÃµesÂ â†’Â nÃ£o as escondas**. Logs claros ajudam a depurar.
* **Pytest** â†’ converte suites Jest backâ€‘end para `pytest` quando migrares para Python (actualmente Node). Se adicionares testes Python, usa `pytest` + muitos `asserts`.
* **Sem manipular chaves em cÃ³digo**: as libs carregam doÂ env automaticamente.
* **TDD**: sempre que acrescentar funcionalidade (ex.: aliases, orÃ§amento), cria primeiro um teste que falha â€” depois implementa.
* **Evita complexidade**: prefere functions pequenas, sem duplicaÃ§Ã£o; se um bloco se repetir 3Ã—, cria helper.
* **Lint sempre verde**: nÃ£o silencies regras; corrigeâ€‘as.
* **Git workflow**: branch featureÂ â†’Â PRÂ â†’Â merge em `develop`; sÃ³ vai para `main` quando aprovado.
* **Sem editar dados crÃ­ticos via script** sem aprovaÃ§Ã£o â€” evita `DELETE` ou truncar tabelas.
* **Quando algo falhar repetidamente, pÃ¡ra e revÃª a arquitectura** antes de remendar.

---

Quando tudo isto estiver verde, a app estÃ¡ pronta.
