#!/usr/bin/env node\n\n/**\n * Standalone Performance Monitor for MariaIntelligence\n * Collects and reports system performance metrics\n */\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst Redis = require('ioredis');\nconst performanceConfig = require('../config/performance.config.js');\n\nclass SystemPerformanceMonitor {\n  constructor() {\n    this.startTime = Date.now();\n    this.metricsHistory = [];\n    this.maxHistorySize = 1440; // 24 hours at 1-minute intervals\n    \n    // Initialize Redis connection\n    try {\n      this.redis = new Redis(performanceConfig.redis);\n      console.log('📊 Performance monitor connected to Redis');\n    } catch (error) {\n      console.warn('⚠️  Redis not available for performance monitoring');\n      this.redis = null;\n    }\n    \n    this.startMonitoring();\n  }\n  \n  /**\n   * Start continuous monitoring\n   */\n  startMonitoring() {\n    const interval = process.env.MONITOR_INTERVAL || 60000; // 1 minute default\n    \n    console.log(`📊 Starting system performance monitoring (interval: ${interval}ms)`);\n    \n    setInterval(async () => {\n      try {\n        const metrics = await this.collectMetrics();\n        await this.processMetrics(metrics);\n        await this.checkAlerts(metrics);\n      } catch (error) {\n        console.error('❌ Error collecting metrics:', error.message);\n      }\n    }, interval);\n    \n    // Initial collection\n    setTimeout(async () => {\n      const metrics = await this.collectMetrics();\n      await this.processMetrics(metrics);\n    }, 1000);\n  }\n  \n  /**\n   * Collect system performance metrics\n   */\n  async collectMetrics() {\n    const timestamp = Date.now();\n    \n    // CPU metrics\n    const cpus = os.cpus();\n    const loadAverage = os.loadavg();\n    \n    // Memory metrics\n    const totalMemory = os.totalmem();\n    const freeMemory = os.freemem();\n    const usedMemory = totalMemory - freeMemory;\n    \n    // Process metrics\n    const processMemory = process.memoryUsage();\n    const processCpu = process.cpuUsage();\n    \n    // Disk metrics (approximation)\n    let diskUsage = null;\n    try {\n      const stats = fs.statSync('.');\n      diskUsage = {\n        used: stats.size || 0,\n        available: freeMemory // Rough approximation\n      };\n    } catch (error) {\n      // Disk stats not available\n    }\n    \n    // Network metrics (if available)\n    let networkStats = null;\n    try {\n      const networkInterfaces = os.networkInterfaces();\n      networkStats = Object.keys(networkInterfaces).length;\n    } catch (error) {\n      // Network stats not available\n    }\n    \n    // Application-specific metrics\n    let appMetrics = null;\n    if (this.redis) {\n      try {\n        const redisInfo = await this.redis.info('memory');\n        const redisMemoryMatch = redisInfo.match(/used_memory:(\\d+)/);\n        appMetrics = {\n          redisMemory: redisMemoryMatch ? parseInt(redisMemoryMatch[1]) : 0\n        };\n      } catch (error) {\n        // Redis metrics not available\n      }\n    }\n    \n    return {\n      timestamp,\n      system: {\n        cpu: {\n          cores: cpus.length,\n          loadAverage: loadAverage,\n          usage: this.calculateCpuUsage(cpus)\n        },\n        memory: {\n          total: totalMemory,\n          used: usedMemory,\n          free: freeMemory,\n          percentage: (usedMemory / totalMemory) * 100\n        },\n        disk: diskUsage,\n        network: networkStats\n      },\n      process: {\n        memory: {\n          heapUsed: processMemory.heapUsed,\n          heapTotal: processMemory.heapTotal,\n          external: processMemory.external,\n          rss: processMemory.rss\n        },\n        cpu: {\n          user: processCpu.user,\n          system: processCpu.system\n        },\n        uptime: process.uptime()\n      },\n      application: appMetrics\n    };\n  }\n  \n  /**\n   * Calculate CPU usage percentage\n   */\n  calculateCpuUsage(cpus) {\n    let totalIdle = 0;\n    let totalTick = 0;\n    \n    cpus.forEach(cpu => {\n      for (let type in cpu.times) {\n        totalTick += cpu.times[type];\n      }\n      totalIdle += cpu.times.idle;\n    });\n    \n    const idle = totalIdle / cpus.length;\n    const total = totalTick / cpus.length;\n    \n    return 100 - ~~(100 * idle / total);\n  }\n  \n  /**\n   * Process and store metrics\n   */\n  async processMetrics(metrics) {\n    // Add to history\n    this.metricsHistory.push(metrics);\n    \n    // Maintain history size\n    if (this.metricsHistory.length > this.maxHistorySize) {\n      this.metricsHistory.shift();\n    }\n    \n    // Store in Redis\n    if (this.redis) {\n      try {\n        const key = `performance:system:${metrics.timestamp}`;\n        await this.redis.setex(key, 3600, JSON.stringify(metrics)); // 1 hour TTL\n        \n        // Store summary\n        const summaryKey = 'performance:system:latest';\n        await this.redis.setex(summaryKey, 300, JSON.stringify(this.generateSummary(metrics))); // 5 minutes TTL\n        \n      } catch (error) {\n        console.error('Failed to store metrics in Redis:', error.message);\n      }\n    }\n    \n    // Log to file\n    await this.logMetrics(metrics);\n    \n    // Display current status\n    this.displayStatus(metrics);\n  }\n  \n  /**\n   * Generate metrics summary\n   */\n  generateSummary(metrics) {\n    const recent = this.metricsHistory.slice(-10); // Last 10 readings\n    \n    if (recent.length === 0) return null;\n    \n    const avgCpu = recent.reduce((sum, m) => sum + m.system.cpu.usage, 0) / recent.length;\n    const avgMemory = recent.reduce((sum, m) => sum + m.system.memory.percentage, 0) / recent.length;\n    const avgLoad = recent.reduce((sum, m) => sum + m.system.cpu.loadAverage[0], 0) / recent.length;\n    \n    return {\n      timestamp: metrics.timestamp,\n      averages: {\n        cpu: Math.round(avgCpu * 100) / 100,\n        memory: Math.round(avgMemory * 100) / 100,\n        load: Math.round(avgLoad * 100) / 100\n      },\n      current: {\n        cpu: metrics.system.cpu.usage,\n        memory: metrics.system.memory.percentage,\n        load: metrics.system.cpu.loadAverage[0]\n      },\n      trends: {\n        cpuTrend: this.calculateTrend(recent.map(m => m.system.cpu.usage)),\n        memoryTrend: this.calculateTrend(recent.map(m => m.system.memory.percentage)),\n        loadTrend: this.calculateTrend(recent.map(m => m.system.cpu.loadAverage[0]))\n      }\n    };\n  }\n  \n  /**\n   * Calculate trend (positive = increasing, negative = decreasing)\n   */\n  calculateTrend(values) {\n    if (values.length < 2) return 0;\n    \n    const recent = values.slice(-5); // Last 5 values\n    const older = values.slice(-10, -5); // Previous 5 values\n    \n    if (older.length === 0) return 0;\n    \n    const recentAvg = recent.reduce((sum, v) => sum + v, 0) / recent.length;\n    const olderAvg = older.reduce((sum, v) => sum + v, 0) / older.length;\n    \n    return ((recentAvg - olderAvg) / olderAvg) * 100;\n  }\n  \n  /**\n   * Check alerts and thresholds\n   */\n  async checkAlerts(metrics) {\n    const thresholds = performanceConfig.monitoring.alerts;\n    const alerts = [];\n    \n    // CPU usage alert\n    if (metrics.system.cpu.usage > thresholds.cpuUsage) {\n      alerts.push({\n        type: 'cpu',\n        severity: 'warning',\n        message: `High CPU usage: ${metrics.system.cpu.usage.toFixed(1)}%`,\n        value: metrics.system.cpu.usage,\n        threshold: thresholds.cpuUsage\n      });\n    }\n    \n    // Memory usage alert\n    if (metrics.system.memory.percentage > thresholds.memoryUsage) {\n      alerts.push({\n        type: 'memory',\n        severity: 'warning',\n        message: `High memory usage: ${metrics.system.memory.percentage.toFixed(1)}%`,\n        value: metrics.system.memory.percentage,\n        threshold: thresholds.memoryUsage\n      });\n    }\n    \n    // Load average alert\n    const loadThreshold = os.cpus().length * 0.8; // 80% of CPU cores\n    if (metrics.system.cpu.loadAverage[0] > loadThreshold) {\n      alerts.push({\n        type: 'load',\n        severity: 'warning',\n        message: `High system load: ${metrics.system.cpu.loadAverage[0].toFixed(2)}`,\n        value: metrics.system.cpu.loadAverage[0],\n        threshold: loadThreshold\n      });\n    }\n    \n    // Process alerts\n    if (alerts.length > 0) {\n      await this.processAlerts(alerts);\n    }\n  }\n  \n  /**\n   * Process and handle alerts\n   */\n  async processAlerts(alerts) {\n    for (const alert of alerts) {\n      console.warn(`🚨 ALERT [${alert.type.toUpperCase()}]: ${alert.message}`);\n      \n      // Store alert in Redis\n      if (this.redis) {\n        try {\n          const alertKey = `performance:alerts:${Date.now()}`;\n          await this.redis.setex(alertKey, 86400, JSON.stringify(alert)); // 24 hours TTL\n        } catch (error) {\n          console.error('Failed to store alert:', error.message);\n        }\n      }\n      \n      // Log alert to file\n      await this.logAlert(alert);\n    }\n  }\n  \n  /**\n   * Log metrics to file\n   */\n  async logMetrics(metrics) {\n    try {\n      const logDir = path.join(process.cwd(), 'logs');\n      if (!fs.existsSync(logDir)) {\n        fs.mkdirSync(logDir, { recursive: true });\n      }\n      \n      const logFile = path.join(logDir, `performance-${new Date().toISOString().split('T')[0]}.json`);\n      const logEntry = {\n        timestamp: metrics.timestamp,\n        summary: this.generateSummary(metrics)\n      };\n      \n      fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\\n');\n    } catch (error) {\n      console.error('Failed to log metrics:', error.message);\n    }\n  }\n  \n  /**\n   * Log alert to file\n   */\n  async logAlert(alert) {\n    try {\n      const logDir = path.join(process.cwd(), 'logs');\n      const alertFile = path.join(logDir, `alerts-${new Date().toISOString().split('T')[0]}.json`);\n      \n      const logEntry = {\n        timestamp: Date.now(),\n        ...alert\n      };\n      \n      fs.appendFileSync(alertFile, JSON.stringify(logEntry) + '\\n');\n    } catch (error) {\n      console.error('Failed to log alert:', error.message);\n    }\n  }\n  \n  /**\n   * Display current status\n   */\n  displayStatus(metrics) {\n    // Clear screen and show status every 10 readings (10 minutes)\n    if (this.metricsHistory.length % 10 === 0) {\n      console.clear();\n      console.log('📊 MariaIntelligence Performance Monitor');\n      console.log('=====================================');\n      console.log(`🕐 ${new Date(metrics.timestamp).toISOString()}`);\n      console.log('');\n      \n      // System metrics\n      console.log('🖥️  System Metrics:');\n      console.log(`   CPU Usage: ${metrics.system.cpu.usage.toFixed(1)}%`);\n      console.log(`   Memory Usage: ${metrics.system.memory.percentage.toFixed(1)}% (${Math.round(metrics.system.memory.used / 1024 / 1024 / 1024)}GB / ${Math.round(metrics.system.memory.total / 1024 / 1024 / 1024)}GB)`);\n      console.log(`   Load Average: ${metrics.system.cpu.loadAverage.map(l => l.toFixed(2)).join(', ')}`);\n      console.log('');\n      \n      // Process metrics\n      console.log('🚀 Process Metrics:');\n      console.log(`   Heap Used: ${Math.round(metrics.process.memory.heapUsed / 1024 / 1024)}MB`);\n      console.log(`   Heap Total: ${Math.round(metrics.process.memory.heapTotal / 1024 / 1024)}MB`);\n      console.log(`   RSS: ${Math.round(metrics.process.memory.rss / 1024 / 1024)}MB`);\n      console.log(`   Uptime: ${Math.round(metrics.process.uptime / 60)} minutes`);\n      console.log('');\n      \n      // Application metrics\n      if (metrics.application && metrics.application.redisMemory) {\n        console.log('📊 Application Metrics:');\n        console.log(`   Redis Memory: ${Math.round(metrics.application.redisMemory / 1024 / 1024)}MB`);\n        console.log('');\n      }\n      \n      // Summary\n      const summary = this.generateSummary(metrics);\n      if (summary) {\n        console.log('📈 10-Minute Averages:');\n        console.log(`   CPU: ${summary.averages.cpu}%`);\n        console.log(`   Memory: ${summary.averages.memory}%`);\n        console.log(`   Load: ${summary.averages.load}`);\n      }\n    } else {\n      // Simple status update\n      process.stdout.write(`\\r📊 ${new Date().toLocaleTimeString()} | CPU: ${metrics.system.cpu.usage.toFixed(1)}% | Memory: ${metrics.system.memory.percentage.toFixed(1)}% | Load: ${metrics.system.cpu.loadAverage[0].toFixed(2)}`);\n    }\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGTERM', () => {\n  console.log('\\n📊 Performance monitor shutting down...');\n  process.exit(0);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('\\n📊 Performance monitor shutting down...');\n  process.exit(0);\n});\n\n// Start monitoring\nconst monitor = new SystemPerformanceMonitor();\n\nconsole.log('📊 Performance monitoring started. Press Ctrl+C to stop.');\n"