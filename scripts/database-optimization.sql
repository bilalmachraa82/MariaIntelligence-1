-- Database Optimization Scripts for MariaIntelligence\n-- Performance tuning for PostgreSQL/Neon\n\n-- ===================================\n-- INDEX OPTIMIZATION\n-- ===================================\n\n-- Properties table indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_properties_created_at ON properties(created_at DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_properties_updated_at ON properties(updated_at DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_properties_name_gin ON properties USING gin(to_tsvector('portuguese', name));\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_properties_status ON properties(status) WHERE status IS NOT NULL;\n\n-- Reservations table indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_property_id ON reservations(property_id);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_owner_id ON reservations(owner_id);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_check_in ON reservations(check_in_date DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_check_out ON reservations(check_out_date DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_status ON reservations(status) WHERE status IS NOT NULL;\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_dates_range ON reservations USING gist(daterange(check_in_date, check_out_date, '[]'));\n\n-- Owners table indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_owners_name_gin ON owners USING gin(to_tsvector('portuguese', name));\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_owners_email ON owners(email) WHERE email IS NOT NULL;\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_owners_phone ON owners(phone) WHERE phone IS NOT NULL;\n\n-- Financial documents indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_documents_property_id ON financial_documents(property_id);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_documents_owner_id ON financial_documents(owner_id);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_documents_date ON financial_documents(date DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_documents_type ON financial_documents(type);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_documents_amount ON financial_documents(amount DESC);\n\n-- Quotations indexes\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_quotations_property_id ON quotations(property_id);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_quotations_created_at ON quotations(created_at DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_quotations_status ON quotations(status);\n\n-- Composite indexes for common queries\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_property_dates ON reservations(property_id, check_in_date, check_out_date);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_docs_property_date ON financial_documents(property_id, date DESC);\nCREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reservations_owner_dates ON reservations(owner_id, check_in_date DESC);\n\n-- ===================================\n-- MATERIALIZED VIEWS FOR ANALYTICS\n-- ===================================\n\n-- Property statistics materialized view\nDROP MATERIALIZED VIEW IF EXISTS property_stats_mv;\nCREATE MATERIALIZED VIEW property_stats_mv AS\nSELECT \n    p.id as property_id,\n    p.name as property_name,\n    COUNT(DISTINCT r.id) as total_reservations,\n    COUNT(DISTINCT CASE WHEN r.check_in_date >= CURRENT_DATE - INTERVAL '30 days' THEN r.id END) as reservations_last_30_days,\n    COALESCE(SUM(CASE WHEN r.check_in_date >= CURRENT_DATE - INTERVAL '30 days' THEN r.total_amount END), 0) as revenue_last_30_days,\n    COALESCE(AVG(r.total_amount), 0) as avg_reservation_value,\n    COALESCE(MAX(r.check_out_date), '1900-01-01'::date) as last_reservation_date,\n    COUNT(DISTINCT fd.id) as total_documents,\n    COALESCE(SUM(CASE WHEN fd.type = 'entrada' THEN fd.amount END), 0) as total_income,\n    COALESCE(SUM(CASE WHEN fd.type = 'saida' THEN fd.amount END), 0) as total_expenses\nFROM properties p\nLEFT JOIN reservations r ON p.id = r.property_id\nLEFT JOIN financial_documents fd ON p.id = fd.property_id\nGROUP BY p.id, p.name;\n\n-- Create unique index on materialized view\nCREATE UNIQUE INDEX ON property_stats_mv (property_id);\n\n-- Monthly revenue materialized view\nDROP MATERIALIZED VIEW IF EXISTS monthly_revenue_mv;\nCREATE MATERIALIZED VIEW monthly_revenue_mv AS\nSELECT \n    DATE_TRUNC('month', r.check_in_date) as month,\n    p.id as property_id,\n    p.name as property_name,\n    COUNT(*) as reservation_count,\n    SUM(r.total_amount) as total_revenue,\n    AVG(r.total_amount) as avg_revenue_per_reservation,\n    SUM(EXTRACT(DAYS FROM (r.check_out_date - r.check_in_date))) as total_nights\nFROM reservations r\nINNER JOIN properties p ON r.property_id = p.id\nWHERE r.check_in_date >= CURRENT_DATE - INTERVAL '24 months'\nGROUP BY DATE_TRUNC('month', r.check_in_date), p.id, p.name\nORDER BY month DESC, total_revenue DESC;\n\n-- Create indexes on monthly revenue view\nCREATE INDEX ON monthly_revenue_mv (month DESC);\nCREATE INDEX ON monthly_revenue_mv (property_id);\nCREATE INDEX ON monthly_revenue_mv (total_revenue DESC);\n\n-- Owner performance materialized view\nDROP MATERIALIZED VIEW IF EXISTS owner_performance_mv;\nCREATE MATERIALIZED VIEW owner_performance_mv AS\nSELECT \n    o.id as owner_id,\n    o.name as owner_name,\n    COUNT(DISTINCT p.id) as property_count,\n    COUNT(DISTINCT r.id) as total_reservations,\n    COALESCE(SUM(r.total_amount), 0) as total_revenue,\n    COALESCE(SUM(CASE WHEN fd.type = 'entrada' THEN fd.amount END), 0) as total_income,\n    COALESCE(SUM(CASE WHEN fd.type = 'saida' THEN fd.amount END), 0) as total_expenses,\n    COALESCE(SUM(CASE WHEN fd.type = 'entrada' THEN fd.amount END), 0) - \n    COALESCE(SUM(CASE WHEN fd.type = 'saida' THEN fd.amount END), 0) as net_profit,\n    COUNT(DISTINCT CASE WHEN r.check_in_date >= CURRENT_DATE - INTERVAL '30 days' THEN r.id END) as recent_reservations\nFROM owners o\nLEFT JOIN properties p ON o.id = p.owner_id\nLEFT JOIN reservations r ON p.id = r.property_id\nLEFT JOIN financial_documents fd ON o.id = fd.owner_id\nGROUP BY o.id, o.name;\n\n-- Create unique index on owner performance view\nCREATE UNIQUE INDEX ON owner_performance_mv (owner_id);\n\n-- ===================================\n-- REFRESH FUNCTIONS FOR MATERIALIZED VIEWS\n-- ===================================\n\n-- Function to refresh all materialized views\nCREATE OR REPLACE FUNCTION refresh_all_materialized_views()\nRETURNS void\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    REFRESH MATERIALIZED VIEW CONCURRENTLY property_stats_mv;\n    REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_revenue_mv;\n    REFRESH MATERIALIZED VIEW CONCURRENTLY owner_performance_mv;\n    \n    -- Log refresh\n    INSERT INTO system_logs (event, message, created_at) \n    VALUES ('materialized_view_refresh', 'All materialized views refreshed', NOW())\n    ON CONFLICT DO NOTHING;\nEND;\n$$;\n\n-- ===================================\n-- PARTITIONING SETUP\n-- ===================================\n\n-- Create audit log table with partitioning (if it doesn't exist)\nCREATE TABLE IF NOT EXISTS audit_logs (\n    id SERIAL,\n    table_name VARCHAR(50) NOT NULL,\n    operation VARCHAR(10) NOT NULL,\n    old_data JSONB,\n    new_data JSONB,\n    user_id INTEGER,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n) PARTITION BY RANGE (created_at);\n\n-- Create partitions for current and next months\nCREATE TABLE IF NOT EXISTS audit_logs_current PARTITION OF audit_logs \nFOR VALUES FROM (DATE_TRUNC('month', CURRENT_DATE)) \nTO (DATE_TRUNC('month', CURRENT_DATE + INTERVAL '1 month'));\n\nCREATE TABLE IF NOT EXISTS audit_logs_next PARTITION OF audit_logs \nFOR VALUES FROM (DATE_TRUNC('month', CURRENT_DATE + INTERVAL '1 month')) \nTO (DATE_TRUNC('month', CURRENT_DATE + INTERVAL '2 months'));\n\n-- ===================================\n-- QUERY OPTIMIZATION FUNCTIONS\n-- ===================================\n\n-- Function for optimized property search\nCREATE OR REPLACE FUNCTION search_properties(\n    search_term TEXT DEFAULT '',\n    limit_count INTEGER DEFAULT 50,\n    offset_count INTEGER DEFAULT 0\n)\nRETURNS TABLE(\n    id INTEGER,\n    name TEXT,\n    location TEXT,\n    total_reservations BIGINT,\n    recent_revenue NUMERIC,\n    rank REAL\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.id,\n        p.name,\n        p.location,\n        ps.total_reservations,\n        ps.revenue_last_30_days,\n        ts_rank(to_tsvector('portuguese', p.name), plainto_tsquery('portuguese', search_term)) as rank\n    FROM properties p\n    LEFT JOIN property_stats_mv ps ON p.id = ps.property_id\n    WHERE \n        CASE \n            WHEN search_term = '' THEN TRUE\n            ELSE to_tsvector('portuguese', p.name) @@ plainto_tsquery('portuguese', search_term)\n        END\n    ORDER BY \n        CASE \n            WHEN search_term = '' THEN ps.revenue_last_30_days\n            ELSE ts_rank(to_tsvector('portuguese', p.name), plainto_tsquery('portuguese', search_term))\n        END DESC NULLS LAST\n    LIMIT limit_count OFFSET offset_count;\nEND;\n$$;\n\n-- Function for reservation availability check\nCREATE OR REPLACE FUNCTION check_availability(\n    property_id_param INTEGER,\n    check_in_param DATE,\n    check_out_param DATE\n)\nRETURNS BOOLEAN\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    conflict_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO conflict_count\n    FROM reservations r\n    WHERE r.property_id = property_id_param\n    AND r.status IN ('confirmed', 'checked_in')\n    AND daterange(r.check_in_date, r.check_out_date, '[]') && \n        daterange(check_in_param, check_out_param, '[]');\n    \n    RETURN conflict_count = 0;\nEND;\n$$;\n\n-- Function for financial summary\nCREATE OR REPLACE FUNCTION get_financial_summary(\n    start_date_param DATE DEFAULT CURRENT_DATE - INTERVAL '30 days',\n    end_date_param DATE DEFAULT CURRENT_DATE,\n    property_id_param INTEGER DEFAULT NULL\n)\nRETURNS TABLE(\n    total_income NUMERIC,\n    total_expenses NUMERIC,\n    net_profit NUMERIC,\n    reservation_income NUMERIC,\n    document_count BIGINT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        COALESCE(SUM(CASE WHEN fd.type = 'entrada' THEN fd.amount END), 0) as total_income,\n        COALESCE(SUM(CASE WHEN fd.type = 'saida' THEN fd.amount END), 0) as total_expenses,\n        COALESCE(SUM(CASE WHEN fd.type = 'entrada' THEN fd.amount END), 0) - \n        COALESCE(SUM(CASE WHEN fd.type = 'saida' THEN fd.amount END), 0) as net_profit,\n        COALESCE((\n            SELECT SUM(r.total_amount) \n            FROM reservations r \n            WHERE r.check_in_date BETWEEN start_date_param AND end_date_param\n            AND (property_id_param IS NULL OR r.property_id = property_id_param)\n        ), 0) as reservation_income,\n        COUNT(*) as document_count\n    FROM financial_documents fd\n    WHERE fd.date BETWEEN start_date_param AND end_date_param\n    AND (property_id_param IS NULL OR fd.property_id = property_id_param);\nEND;\n$$;\n\n-- ===================================\n-- PERFORMANCE MONITORING\n-- ===================================\n\n-- Create system logs table for monitoring\nCREATE TABLE IF NOT EXISTS system_logs (\n    id SERIAL PRIMARY KEY,\n    event VARCHAR(50) NOT NULL,\n    message TEXT,\n    metadata JSONB,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Index for system logs\nCREATE INDEX IF NOT EXISTS idx_system_logs_event_date ON system_logs(event, created_at DESC);\n\n-- Function to log slow queries\nCREATE OR REPLACE FUNCTION log_slow_query(\n    query_text TEXT,\n    execution_time NUMERIC,\n    parameters JSONB DEFAULT NULL\n)\nRETURNS void\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO system_logs (event, message, metadata) \n    VALUES (\n        'slow_query', \n        query_text, \n        jsonb_build_object(\n            'execution_time_ms', execution_time,\n            'parameters', parameters,\n            'timestamp', NOW()\n        )\n    );\nEND;\n$$;\n\n-- ===================================\n-- MAINTENANCE PROCEDURES\n-- ===================================\n\n-- Function to update table statistics\nCREATE OR REPLACE FUNCTION update_statistics()\nRETURNS void\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    ANALYZE properties;\n    ANALYZE reservations;\n    ANALYZE owners;\n    ANALYZE financial_documents;\n    ANALYZE quotations;\n    \n    INSERT INTO system_logs (event, message) \n    VALUES ('statistics_update', 'Database statistics updated');\nEND;\n$$;\n\n-- Function for database maintenance\nCREATE OR REPLACE FUNCTION database_maintenance()\nRETURNS void\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- Update statistics\n    PERFORM update_statistics();\n    \n    -- Refresh materialized views\n    PERFORM refresh_all_materialized_views();\n    \n    -- Vacuum and reindex if needed\n    -- Note: These would typically be run separately with appropriate locks\n    \n    INSERT INTO system_logs (event, message) \n    VALUES ('database_maintenance', 'Database maintenance completed');\nEND;\n$$;\n\n-- ===================================\n-- SCHEDULED MAINTENANCE (Extension needed: pg_cron)\n-- ===================================\n\n-- Note: These require the pg_cron extension which may not be available on all platforms\n-- For Neon/managed databases, these would be handled differently\n\n-- Schedule materialized view refresh every hour\n-- SELECT cron.schedule('refresh-materialized-views', '0 * * * *', 'SELECT refresh_all_materialized_views();');\n\n-- Schedule statistics update daily at 2 AM\n-- SELECT cron.schedule('update-statistics', '0 2 * * *', 'SELECT update_statistics();');\n\n-- Schedule full maintenance weekly on Sunday at 3 AM\n-- SELECT cron.schedule('database-maintenance', '0 3 * * 0', 'SELECT database_maintenance();');\n\n-- ===================================\n-- CONNECTION POOLING RECOMMENDATIONS\n-- ===================================\n\n/*\nFor connection pooling optimization, set these parameters:\n\n-- PostgreSQL configuration (postgresql.conf or equivalent)\nmax_connections = 100\nshared_buffers = 256MB\neffective_cache_size = 1GB\nwork_mem = 4MB\nmaintenance_work_mem = 64MB\nrandom_page_cost = 1.1\neffective_io_concurrency = 200\n\n-- For Node.js connection pool (in application)\npool: {\n  min: 2,\n  max: 20,\n  acquireTimeoutMillis: 30000,\n  createTimeoutMillis: 30000,\n  destroyTimeoutMillis: 5000,\n  idleTimeoutMillis: 30000\n}\n*/\n\n-- Final optimization: Create a summary view of optimization status\nCREATE OR REPLACE VIEW optimization_status AS\nSELECT \n    'indexes' as optimization_type,\n    COUNT(*) as count,\n    'Database indexes created for performance' as description\nFROM pg_indexes \nWHERE tablename IN ('properties', 'reservations', 'owners', 'financial_documents', 'quotations')\n\nUNION ALL\n\nSELECT \n    'materialized_views' as optimization_type,\n    COUNT(*) as count,\n    'Materialized views for analytics' as description\nFROM pg_matviews\nWHERE matviewname LIKE '%_mv'\n\nUNION ALL\n\nSELECT \n    'functions' as optimization_type,\n    COUNT(*) as count,\n    'Optimization functions created' as description\nFROM pg_proc p\nJOIN pg_namespace n ON p.pronamespace = n.oid\nWHERE n.nspname = 'public' \nAND p.proname IN ('refresh_all_materialized_views', 'search_properties', 'check_availability', 'get_financial_summary');\n\n-- Log the optimization completion\nINSERT INTO system_logs (event, message, metadata) \nVALUES (\n    'database_optimization', \n    'Database optimization scripts executed successfully', \n    jsonb_build_object(\n        'timestamp', NOW(),\n        'version', '1.0',\n        'optimizations', jsonb_build_array(\n            'indexes',\n            'materialized_views', \n            'query_functions',\n            'maintenance_procedures'\n        )\n    )\n);\n\n-- Show optimization status\nSELECT * FROM optimization_status;\n"